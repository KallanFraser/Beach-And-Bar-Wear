/** @format */

// pages/api/trackVisit.js
import { pool } from "../Database/Database.js"; // adjust path to your pool
import geoip from "geoip-lite";

export default async function trackingHandler(req, res) {
	// Only allow POST (you could allow GET, but POST is semantically better for "logging")
	if (req.method !== "POST") {
		res.setHeader("Allow", ["POST"]);
		return res.status(405).end(`Method ${req.method} Not Allowed`);
	}

	const client = await pool.connect();
	try {
		// ─── 1) Get IP address ────────────────────────────────────────────────────────────────
		// If behind a proxy (Vercel, Render, etc.), it’s typically in X-Forwarded-For:
		let ip = null;
		const xff = req.headers["x-forwarded-for"];
		if (xff) {
			ip = Array.isArray(xff) ? xff[0] : xff.split(",")[0].trim();
		} else {
			ip = req.socket.remoteAddress;
		}

		// Normalize IPv6 localhost to 127.0.0.1 if needed:
		if (ip === "::1" || ip === "127.0.0.1") {
			ip = "127.0.0.1";
		}

		// ─── 2) Run GeoIP lookup ─────────────────────────────────────────────────────────────
		const geo = geoip.lookup(ip) || {};
		const country = geo.country || null; // e.g. "US"
		const region = geo.region || null; // e.g. "CA"
		const city = geo.city || null; // e.g. "San Jose"
		let latitude = null;
		let longitude = null;
		if (geo.ll && geo.ll.length === 2) {
			latitude = geo.ll[0];
			longitude = geo.ll[1];
		}
		// NOTE: geoip-lite doesn’t directly give timezone. If you need timezone
		// you can use a separate library (maxmind’s database) or infer from lat/long.

		// ─── 3) Parse standard headers ──────────────────────────────────────────────────────
		const user_agent = req.headers["user-agent"] || "";
		const accept_language = req.headers["accept-language"] || "";
		const referer = req.headers["referer"] || null;
		const host = req.headers["host"] || null;

		// ─── 4) Extract path, query_string from the request URL ───────────────────────────────
		// In Next.js, req.url includes path and query string (e.g. "/?utm_source=foo")
		const urlObj = new URL(req.headers.referer || `http://${host}/`, `http://${host}`);
		// If you want the path+query that triggered this API route specifically, you could use:
		//   const urlObj = new URL(req.url, `http://${host}`);
		// But typically the frontend will pass its own location.href in the body. We’ll see below.

		const path = urlObj.pathname; // e.g. "/"
		const query_string = urlObj.search || null; // e.g. "?utm_source=google&utm_medium=cpc"

		// ─── 5) Parse UTM params from the URL ─────────────────────────────────────────────────
		// We’ll try to parse from the original page URL, which the frontend can pass in the body.
		// If not provided, we fall back to req.url’s query.
		const clientData = req.body || {}; // see frontend code below
		// frontend should send: { pageUrl: window.location.href, ...otherData }
		const pageUrl = clientData.pageUrl || `${urlObj.origin}${path}${query_string}`;
		const pageUrlObj = new URL(pageUrl);
		const searchParams = pageUrlObj.searchParams;
		const utm_source = searchParams.get("utm_source");
		const utm_medium = searchParams.get("utm_medium");
		const utm_campaign = searchParams.get("utm_campaign");
		const utm_term = searchParams.get("utm_term");
		const utm_content = searchParams.get("utm_content");

		// ─── 6) Extract client‐side data sent in req.body ────────────────────────────────────
		// (These must have been collected by the frontend JavaScript on page load.)
		const {
			screen_width,
			screen_height,
			viewport_width,
			viewport_height,
			device_pixel_ratio,
			browser_language,
			platform,
			cookie_enabled,
			java_enabled,
			is_mobile,
			is_tablet,
			is_desktop,
			timezone_offset, // e.g. -420 for PDT
			referring_domain, // frontend can derive from document.referrer
			cookie_id, // optionally generated by frontend
			raw_query_params, // if you want ALL query params as JSON
			raw_headers, // if you want a copy of all headers as JSON
		} = clientData;

		// ─── 7) Build & run INSERT ────────────────────────────────────────────────────────────
		const insertSQL = `
      INSERT INTO visits(
        ip, user_agent, accept_language, referer, host, path, query_string,
        utm_source, utm_medium, utm_campaign, utm_term, utm_content, cookie_id,
        country, region, city, latitude, longitude, timezone,
        screen_width, screen_height, viewport_width, viewport_height, device_pixel_ratio,
        browser_language, platform, cookie_enabled, java_enabled,
        is_mobile, is_tablet, is_desktop, referring_domain,
        raw_headers, raw_query_params
      )
      VALUES(
        $1, $2, $3, $4, $5, $6, $7,
        $8, $9, $10, $11, $12, $13,
        $14, $15, $16, $17, $18, $19,
        $20, $21, $22, $23, $24,
        $25, $26, $27, $28,
        $29, $30, $31, $32,
        $33::jsonb, $34::jsonb
      )
    `;

		const values = [
			ip,
			user_agent,
			accept_language,
			referer,
			host,
			path,
			query_string,

			utm_source,
			utm_medium,
			utm_campaign,
			utm_term,
			utm_content,
			clientData.cookie_id || null,

			country,
			region,
			city,
			latitude,
			longitude,
			null, // timezone (we didn’t derive it above with geoip-lite)

			clientData.screen_width ?? null,
			clientData.screen_height ?? null,
			clientData.viewport_width ?? null,
			clientData.viewport_height ?? null,
			clientData.device_pixel_ratio ?? null,

			clientData.browser_language || null,
			clientData.platform || null,
			clientData.cookie_enabled ?? null,
			clientData.java_enabled ?? null,

			clientData.is_mobile ?? null,
			clientData.is_tablet ?? null,
			clientData.is_desktop ?? null,
			clientData.referring_domain || null,

			JSON.stringify(req.headers), // raw_headers
			JSON.stringify(req.query || {}), // raw_query_params
		];

		await client.query(insertSQL, values);

		return res.status(200).json({ success: true });
	} catch (err) {
		console.error("[❌] trackVisit error:", err);
		return res.status(500).json({ error: "Failed to log visit" });
	} finally {
		client.release();
	}
}
